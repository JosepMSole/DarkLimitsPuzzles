<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DARK LIMITS ‚Äì Puzzle (v0.4)</title>
  <style>
    :root{
      --text:#e8ecff;
      --muted:#a9b4ff;
      --panel: rgba(10,14,28,0.62);
      --panel2: rgba(10,14,28,0.40);
      --stroke: rgba(255,255,255,0.14);
      --accent: #6aa7ff;
      --good: #33d17a;
      --warn: #ffd166;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      overflow:hidden;
      background:#050812;
    }

    /* ===== Intro (mandatory) ===== */
    .overlayFull{
      position:fixed; inset:0;
      z-index:99999;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .overlayFull.hidden{ display:none; }
    .overlayFull video, .overlayFull img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }
    .introImgZoom{
      transform:scale(1);
      animation: introZoom 2s ease-in-out forwards;
    }
    @keyframes introZoom{
      0%{ transform:scale(1); }
      100%{ transform:scale(1.08); }
    }
    .startGate{
      position:absolute; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      z-index:1;
    }
    .startGate.on{ display:flex; }
    .startBtn{
      appearance:none;
      border:1px solid rgba(255,255,255,0.22);
      background: rgba(17,26,51,0.70);
      color:var(--text);
      padding:14px 16px;
      border-radius:16px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.2px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.45);
    }

    /* ===== Post-level full video ===== */
    .postOverlay{
      position:fixed; inset:0;
      z-index:99998;
      background:#000;
      display:none;
    }
    .postOverlay.on{ display:block; }
    .postOverlay video{ width:100%; height:100%; object-fit:cover; }

    /* ===== Background video ===== */
    .bg{
      position:fixed;
      inset:0;
      z-index:-2;
      overflow:hidden;
      background:
        radial-gradient(1200px 700px at 50% -10%, rgba(106,167,255,0.18), rgba(0,0,0,0) 60%),
        radial-gradient(1200px 800px at 50% 110%, rgba(255,255,255,0.06), rgba(0,0,0,0) 55%),
        #050812;
    }
    .bg video{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      opacity:1;
      filter: saturate(0.95) contrast(1.05);
    }

    /* ===== Screens ===== */
    .screen{
      position:relative;
      min-height:100vh;
      display:none;
      padding:18px;
    }
    .screen.on{ display:block; }

    /* ===== Stage ===== */
    .stage{
      position:fixed;
      inset:0;
      z-index:1;
      pointer-events:auto;
    }

    /* ===== Board ===== */
    .board{
      position:absolute;
      width:min(760px, 100%);
      aspect-ratio: 1 / 1;
      border-radius:18px;
      overflow:hidden;
      background: rgba(0,0,0,0.22);
      border:1px solid rgba(255,255,255,0.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35);
      pointer-events:none;
    }
    .boardGlow{
      position:absolute;
      inset:0;
      pointer-events:none;
      background: radial-gradient(800px 500px at 50% 0%, rgba(106,167,255,0.18), transparent 60%);
    }

    /* ===== Pieces ===== */
    .piece{
      position:absolute;
      touch-action:none;
      cursor:grab;
      user-select:none;
      will-change:left, top, transform, filter;
      transition: filter .12s ease;
      filter:
        drop-shadow(0 10px 18px rgba(0,0,0,0.35))
        drop-shadow(0 0 6px rgba(255,255,255,0.22))
        drop-shadow(0 0 18px rgba(183,224,255,0.45))
        drop-shadow(0 0 44px rgba(119,178,255,0.55));
    }
    .piece:active{ cursor:grabbing; }
    .piece.locked{
      cursor:default;
      filter: drop-shadow(0 6px 12px rgba(0,0,0,0.28));
    }
    .piece canvas{ display:block; background: transparent; }

    /* ===== Windows ===== */
    .windows{
      position:fixed;
      inset:0;
      z-index:2;
      pointer-events:none;
    }
    .window{
      position:absolute;
      max-width: calc(100vw - 24px);
      border-radius:18px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      overflow:hidden;
      backdrop-filter: blur(10px);
      pointer-events:auto;
    }
    .windowHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:9px 10px;
      border-bottom:1px solid rgba(255,255,255,0.10);
      cursor:grab;
      user-select:none;
      background: rgba(0,0,0,0.12);
    }
    .windowHeader:active{ cursor:grabbing; }
    .windowTitle{
      font-weight:900;
      letter-spacing:.2px;
      font-size:13px;
      color:rgba(232,236,255,0.95);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .windowBody{ padding:12px; }

    .closeBtn{
      width:28px; height:28px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(17,26,51,0.55);
      color:var(--text);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      font-weight:900;
      line-height:1;
      transition:.15s ease;
      flex:0 0 auto;
    }

    h2{ margin:0; font-size:16px; letter-spacing:0.2px; }
    p{ margin:10px 0; color:var(--muted); line-height:1.35; font-size:14px; }
    .small{ font-size:12px; color:var(--muted); }

    .btns{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    button, a.btnlink{
      appearance:none;
      border:1px solid rgba(255,255,255,0.18);
      background: rgba(17,26,51,0.55);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.15px;
      transition:.15s ease;
      user-select:none;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
    }
    .primary{
      background: linear-gradient(180deg, rgba(106,167,255,0.40), rgba(106,167,255,0.14));
      border-color: rgba(106,167,255,0.60);
    }

    .toast{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.14);
      font-size:13px;
      color:var(--muted);
      display:none;
    }
    .toast.warn{ border-color: rgba(255,209,102,0.55); color: rgba(255,209,102,0.95); display:block; }

    /* ===== Menu ===== */
    .menuFooter{ text-align:center; }
    .pillLink{
      display:inline-block;
      padding:2px 10px;
      border-radius:999px;
      background: rgba(255,255,255,0.92);
      color:#000 !important;
      text-decoration:none;
      font-weight:900;
      letter-spacing:.25px;
    }
        .menuTextBig{
      font-size: 18px;
      line-height: 1.25;
      color: rgba(232,236,255,0.96);
      font-weight: 400;
      letter-spacing: .2px;
      text-align:center;
    }

    
    to{ width:60ch; }
    }
    /* ===== Controls compact + stats emphasized ===== */
    .controlsCompact .windowBody{ padding:10px; }
    .controlsCompact .miniTitle{
      font-weight:900;
      font-size: clamp(20px, 9vw, 34px);
      letter-spacing:.6px;
      text-align:center;
      width:100%;
      line-height:1.05;
    }
    .controlsCompact .miniDesc{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
      text-align:center;
      width:100%;
    }
    .controlsCompact button{ padding:8px 10px; font-size:12px; }
    .controlsCompact .btns{
      gap:6px;
      margin-top:8px;
      justify-content:center;
    }
    .audioRow{
      margin-top:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      flex-wrap:wrap;
      padding:8px 10px;
      border-radius:14px;
      background: rgba(0,0,0,0.18);
      border:1px solid rgba(255,255,255,0.10);
    }
    .audioRow label{
      font-size:11px;
      color:var(--muted);
      font-weight:900;
      letter-spacing:.2px;
    }
    .audioRow input[type="range"]{ width:110px; }

    .statsBig{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,0.18);
      border:1px solid rgba(255,255,255,0.10);
      display:grid;
      gap:8px;
    }
    .statsBig .row{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      color: rgba(232,236,255,0.92);
      font-weight:900;
      letter-spacing:.2px;
      font-size:15px;
    }
    .statsBig .row b{
      color: var(--text);
      font-weight:900;
      font-size:20px;
      letter-spacing:.2px;
    }

    
    /* ===== Completion FX (restaurado v0.3) ===== */
    @keyframes warpPulse {
      0%{transform:scale(1); opacity:.85; filter:blur(0px);}
      20%{transform:scale(1.06); opacity:1; filter:blur(.5px);}
      45%{transform:scale(1.02); opacity:1; filter:blur(0px);}
      70%{transform:scale(1.08); opacity:1; filter:blur(.6px);}
      100%{transform:scale(1); opacity:.9; filter:blur(0px);}
    }
    @keyframes pieceHyper {
      0%{transform:translate(0,0) rotate(0) scale(1);}
      10%{transform:translate(8px,-18px) rotate(7deg) scale(1.12);}
      22%{transform:translate(-18px,14px) rotate(-10deg) scale(1.06);}
      36%{transform:translate(20px,10px) rotate(11deg) scale(1.14);}
      55%{transform:translate(-12px,-16px) rotate(-9deg) scale(1.08);}
      76%{transform:translate(10px,6px) rotate(7deg) scale(1.10);}
      100%{transform:translate(0,0) rotate(0) scale(1);}
    }
    @keyframes glowStrobe {
      0%{filter:
          drop-shadow(0 10px 18px rgba(0,0,0,0.35))
          drop-shadow(0 0 10px rgba(255,255,255,0.22))
          drop-shadow(0 0 38px rgba(183,224,255,0.45))
          drop-shadow(0 0 120px rgba(119,178,255,0.55));}
      50%{filter:
          drop-shadow(0 10px 18px rgba(0,0,0,0.35))
          drop-shadow(0 0 22px rgba(255,255,255,0.40))
          drop-shadow(0 0 88px rgba(183,224,255,0.80))
          drop-shadow(0 0 260px rgba(119,178,255,0.80));}
      100%{filter:
          drop-shadow(0 10px 18px rgba(0,0,0,0.35))
          drop-shadow(0 0 10px rgba(255,255,255,0.22))
          drop-shadow(0 0 38px rgba(183,224,255,0.45))
          drop-shadow(0 0 120px rgba(119,178,255,0.55));}
    }
    @keyframes shimmer { 0%{opacity:1;} 50%{opacity:.90;} 100%{opacity:1;} }
    .celebrate .boardGlow{ animation:warpPulse 2s ease-in-out both; opacity:1; }
    .celebrate .piece{
      animation: pieceHyper 2s cubic-bezier(.18,.95,.12,1) both, glowStrobe .18s ease-in-out infinite, shimmer .16s ease-in-out infinite;
    }

/* ===== Completion FX overlay flash ===== */
    .fxFlash{
      position:absolute;
      inset:-20%;
      pointer-events:none;
      opacity:0;
      background:
        radial-gradient(closest-side at 50% 50%, rgba(255,255,255,0.55), rgba(119,178,255,0.36) 35%, rgba(0,0,0,0) 72%),
        radial-gradient(closest-side at 28% 58%, rgba(183,224,255,0.28), rgba(0,0,0,0) 65%),
        radial-gradient(closest-side at 72% 40%, rgba(119,178,255,0.26), rgba(0,0,0,0) 65%);
      mix-blend-mode: screen;
      filter: blur(6px);
      z-index: 1;
    }
    @keyframes flashPop{
      0%{opacity:0; transform:scale(.98);}
      8%{opacity:1; transform:scale(1.02);}
      22%{opacity:.35; transform:scale(1.06);}
      40%{opacity:.98; transform:scale(1.03);}
      70%{opacity:.20; transform:scale(1.08);}
      100%{opacity:0; transform:scale(1.10);}
    }
    .celebrate .fxFlash{ animation:flashPop 2s ease-in-out both; }
    .stage.disabled{ pointer-events:none; }

    /* ===== Completion window ===== */
    .completeWrap{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:6px 0;
    }
    .completeImg{
      width:min(360px, 70vw);
      height:auto;
      display:block;
    }
    .completeLine{
      margin-top:10px;
      color:var(--muted);
      font-size:16px;
      font-weight:900;
      text-align:center;
    }

    @media (max-width: 520px){
      .menuTextBig{ font-size:16px; font-weight:400; }
      .audioRow input[type="range"]{ width:92px; }
      .statsBig .row{ font-size:14px; }
      .statsBig .row b{ font-size:18px; }
    }
  </style>
</head>
<body>
  <!-- Intro overlay -->
  <div id="introOverlay" class="overlayFull" aria-hidden="false">
    <video id="introVideo" playsinline preload="auto"></video>
    <img id="introImg" alt="Disturbing Games" style="display:none;" />
    <div id="startGate" class="startGate" aria-hidden="false">
      <button id="startBtn" class="startBtn" type="button">Toca para comenzar</button>
    </div>
  </div>

  <!-- Post-level overlay -->
  <div id="postOverlay" class="postOverlay" aria-hidden="true">
    <video id="postVideo" playsinline preload="auto"></video>
    <div id="postGate" class="startGate" aria-hidden="false">
      <button id="postBtn" class="startBtn" type="button">Toca para continuar</button>
    </div>
  </div>

  <!-- Background -->
  <div class="bg" aria-hidden="true">
    <video id="bgVideo" autoplay muted loop playsinline></video>
  </div>

  <!-- Audio -->
  <audio id="bgAudio" loop preload="auto"></audio>
  <audio id="sfxSuccess" preload="auto"></audio>

  <!-- Stage (pieces) -->
  <div id="stage" class="stage" aria-hidden="false" style="display:none;">
    <div id="fxFlash" class="fxFlash" aria-hidden="true"></div>
    <div id="board" class="board" aria-hidden="true">
      <div class="boardGlow"></div>
    </div>
  </div>

  <!-- Windows container -->
  <div id="windows" class="windows"></div>

  <!-- Screens -->
  <section id="screenMenu" class="screen"></section>
  <section id="screenHow" class="screen"></section>
  <section id="screenGame" class="screen"></section>

<script>
(() => {
  // ========= Assets =========
  const ASSETS = "assets/";

  // ========= Mobile detection =========
  const isMobile = (() => {
    const ua = navigator.userAgent || "";
    const coarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
    return /Mobi|Android|iPhone|iPad|iPod/i.test(ua) || coarse;
  })();

  // ========= Files / Levels =========
  const LEVELS = [
    { key:"1",     name:"Puzzle 1",     img:ASSETS+"puzzle1.jpg",     bg:ASSETS+"bglevel1.webm", audio:ASSETS+"audio1.mp3", pieces: 9  },
    { key:"2",     name:"Puzzle 2",     img:ASSETS+"puzzle2.jpg",     bg:ASSETS+"bglevel2.webm", audio:ASSETS+"audio2.mp3", pieces: 16 },
    { key:"3",     name:"Puzzle 3",     img:ASSETS+"puzzle3.jpg",     bg:ASSETS+"bglevel3.webm", audio:ASSETS+"audio3.mp3", pieces: 25 },
    { key:"4",     name:"Puzzle 4",     img:ASSETS+"puzzle4.jpg",     bg:ASSETS+"bglevel4.webm", audio:ASSETS+"audio4.mp3", pieces: 36 },
    { key:"5",     name:"Puzzle 5",     img:ASSETS+"puzzle5.jpg",     bg:ASSETS+"bglevel5.webm", audio:ASSETS+"audio5.mp3", pieces: 49 },
    { key:"bonus", name:"Puzzle Bonus", img:ASSETS+"puzzlebonus.jpg", bg:ASSETS+"bglevel6.webm", audio:ASSETS+"audio6.mp3", pieces: 64 },
  ];

  const MENU_BG = ASSETS + "bgmenu.webm";
  const MENU_AUDIO = ASSETS + "audiomenu.mp3";

  const INTRO_VIDEO = ASSETS + "introdisturbinggames.webm";
  const INTRO_MOBILE_IMG = ASSETS + "disturbinggames_frameintroV.jpg";

  function postVideoForLevel(idx){
    // idx es levelIndex (0-based). postlevel1 para puzzle1, ... postlevel6 para bonus
    return ASSETS + "postlevel" + String(idx + 1) + ".webm";
  }
  const SFX_SUCCESS = ASSETS + "exitosound01.mp3";

  const COMPLETE_IMG = ASSETS + "complete.png";
  const COMPLETE_FINAL_IMG = ASSETS + "completefinal.png";

  // ========= DOM =========
  const $ = (id) => document.getElementById(id);

  const screenMenu = $("screenMenu");
  const screenHow  = $("screenHow");
  const screenGame = $("screenGame");

  const windows = $("windows");
  const stage = $("stage");
  const board = $("board");

  const bgVideo = $("bgVideo");
  const bgAudio = $("bgAudio");
  const sfxSuccess = $("sfxSuccess");

  const introOverlay = $("introOverlay");
  const introVideo = $("introVideo");
  const introImg = $("introImg");
  const startGate = $("startGate");
  const startBtn = $("startBtn");

  const postOverlay = $("postOverlay");
  const postVideo = $("postVideo");
  const postGate = $("postGate");
  const postBtn = $("postBtn");

  // ========= Safe play helper =========
  function tryPlay(media){
    if (!media) return Promise.resolve();
    const p = media.play();
    if (p && typeof p.catch === "function") return p.catch(() => {});
    return Promise.resolve();
  }

  // ========= Global audio handling =========
  let audioEnabled = true;
  let lastBgVolume = 0.65;

  // progreso
  let gameCompletedAll = false;

  function setBackground(src){
    const cur = bgVideo.dataset.src || "";
    if (cur === src){
      tryPlay(bgVideo);
      return;
    }
    bgVideo.dataset.src = src;
    bgVideo.pause();
    bgVideo.innerHTML = "";
    const s = document.createElement("source");
    s.src = src;
    s.type = "video/webm";
    bgVideo.appendChild(s);
    bgVideo.load();
    tryPlay(bgVideo);
  }

  function setAudio(src){
    const cur = bgAudio.dataset.src || "";
    if (cur === src){
      bgAudio.muted = !audioEnabled;
      bgAudio.volume = Math.max(0, Math.min(1, lastBgVolume));
      if (audioEnabled) tryPlay(bgAudio);
      return;
    }
    bgAudio.dataset.src = src;
    bgAudio.pause();
    bgAudio.src = src;
    bgAudio.load();
    bgAudio.loop = true;
    bgAudio.volume = Math.max(0, Math.min(1, lastBgVolume));
    bgAudio.muted = !audioEnabled;
    if (audioEnabled) tryPlay(bgAudio);
  }

  function muteBgMusic(){
    lastBgVolume = bgAudio.volume || lastBgVolume;
    bgAudio.volume = 0;
    bgAudio.muted = true;
  }
  function unmuteBgMusic(){
    bgAudio.muted = !audioEnabled;
    bgAudio.volume = Math.max(0, Math.min(1, lastBgVolume));
    if (audioEnabled) tryPlay(bgAudio);
  }

  function toggleAudio(statusEl, btnEl){
    audioEnabled = !audioEnabled;
    bgAudio.muted = !audioEnabled;
    if (!audioEnabled){
      bgAudio.pause();
      if (btnEl) btnEl.textContent = "üîá";
      if (statusEl) statusEl.textContent = "Silenciado";
    } else {
      if (btnEl) btnEl.textContent = "üîä";
      tryPlay(bgAudio);
      if (statusEl) statusEl.textContent = "Reproduciendo";
    }
  }

  // ========= Screen management =========
  function showScreen(which){
    screenMenu.classList.toggle("on", which === "menu");
    screenHow.classList.toggle("on", which === "how");
    screenGame.classList.toggle("on", which === "game");

    const inGame = (which === "game");
    stage.style.display = inGame ? "block" : "none";
    windows.style.display = "block";
  }

  // ========= Draggable windows =========
  let winZ = 10;
  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

  function makeWindow({ id, title, contentHTML, x=40, y=40, w=360, closable=true, onClose=null, draggable=true, showHeader=true }){
    const el = document.createElement("div");
    el.className = "window";
    el.dataset.winId = id;
    el.style.left = x + "px";
    el.style.top  = y + "px";
    el.style.width = w + "px";
    el.style.zIndex = String(++winZ);

    let header = null;

    if (showHeader){
      header = document.createElement("div");
      header.className = "windowHeader";
      const t = document.createElement("div");
      t.className = "windowTitle";
      t.textContent = title || "";
      header.appendChild(t);

      if (closable){
        const xbtn = document.createElement("button");
        xbtn.className = "closeBtn";
        xbtn.type = "button";
        xbtn.textContent = "‚úï";
        xbtn.addEventListener("click", (ev) => {
          ev.stopPropagation();
          el.style.display = "none";
          if (typeof onClose === "function") onClose();
        });
        header.appendChild(xbtn);
      } else {
        const sp = document.createElement("div");
        sp.style.width = "28px";
        sp.style.height = "28px";
        header.appendChild(sp);
      }

      header.style.cursor = draggable ? "grab" : "default";
      el.appendChild(header);
    }

    const body = document.createElement("div");
    body.className = "windowBody";
    body.innerHTML = contentHTML;
    el.appendChild(body);

    el.addEventListener("pointerdown", () => { el.style.zIndex = String(++winZ); });

    if (header && draggable){
      let dragging = false, startPX=0, startPY=0, startX=0, startY=0;

      header.addEventListener("pointerdown", (ev) => {
        if (ev.target && ev.target.classList && ev.target.classList.contains("closeBtn")) return;
        dragging = true;
        header.setPointerCapture(ev.pointerId);
        el.style.zIndex = String(++winZ);
        startPX = ev.clientX; startPY = ev.clientY;
        startX = parseFloat(el.style.left) || 0;
        startY = parseFloat(el.style.top) || 0;
      });

      header.addEventListener("pointermove", (ev) => {
        if (!dragging) return;
        const dx = ev.clientX - startPX;
        const dy = ev.clientY - startPY;

        const vw = window.innerWidth;
        const vh = window.innerHeight;

        const rect = el.getBoundingClientRect();
        const newX = clamp(startX + dx, 8 - rect.width + 60, vw - 8 - 60);
        const newY = clamp(startY + dy, 8, vh - 8 - 60);

        el.style.left = newX + "px";
        el.style.top  = newY + "px";
      });

      const endDrag = () => { dragging = false; };
      header.addEventListener("pointerup", endDrag);
      header.addEventListener("pointercancel", endDrag);
    }

    windows.appendChild(el);
    return el;
  }

  function removeAllWindows(){ windows.innerHTML = ""; }
  function getWindow(id){ return windows.querySelector(`.window[data-win-id="${CSS.escape(id)}"]`); }

  function showToastIn(winId, msg, kind=""){
    const w = getWindow(winId);
    if (!w) return;
    const toast = w.querySelector(".toast");
    if (!toast) return;
    toast.style.display = msg ? "block" : "none";
    toast.className = "toast" + (kind ? ` ${kind}` : "");
    toast.textContent = msg || "";
    clearTimeout(toast._t);
    if (msg){
      toast._t = setTimeout(() => { toast.style.display = "none"; }, 1600);
    }
  }

  // ========= Intro flow =========
  async function runIntroThenMenu(){
    // Keep menu bg/audio OFF until intro finishes
    bgVideo.pause();
    bgAudio.pause();

    // Preload sfx
    sfxSuccess.src = SFX_SUCCESS;
    sfxSuccess.load();

    if (isMobile){
      introVideo.style.display = "none";
      introImg.style.display = "block";
      introImg.src = INTRO_MOBILE_IMG;
      introImg.className = "introImgZoom";
      await new Promise(r => setTimeout(r, 2000));
      introOverlay.classList.add("hidden");
      enterMenu();
      return;
    }

    // Desktop: mandatory video. If autoplay fails, show tap-to-start gate.
    introImg.style.display = "none";
    introVideo.style.display = "block";
    introVideo.controls = false;
    introVideo.muted = false;
    introVideo.playsInline = true;
    introVideo.src = INTRO_VIDEO;
    introVideo.load();

    const started = await tryPlay(introVideo);
    // If not playing, show gate.
    if (introVideo.paused){
      startGate.classList.add("on");
    }

    startBtn.addEventListener("click", async () => {
      startGate.classList.remove("on");
      await tryPlay(introVideo);
    });

    introVideo.addEventListener("ended", () => {
      introOverlay.classList.add("hidden");
      enterMenu();
    }, { once:true });
  }

  function enterMenu(){
    showScreen("menu");
    buildMenu(); // also sets bgmenu+audio
  }

  // ========= Menu / Submenus (always bgmenu + audiomenu) =========
  function ensureMenuAmbience(){
    setBackground(MENU_BG);
    setAudio(MENU_AUDIO);
  }

  function buildMenu(){
    removeAllWindows();
    stage.style.display = "none";
    ensureMenuAmbience();

    const w = Math.min(680, window.innerWidth - 36);
    const x = Math.round((window.innerWidth - w)/2);
    const y = Math.round((window.innerHeight - 360)/2);

    const menuWin = makeWindow({
      id: "menu",
      title: "",
      x, y, w,
      closable: false,
      draggable: false,
      showHeader: false,
      contentHTML: `
        <div style="display:flex; justify-content:center; margin: 4px 0 10px;">
          <img src="${ASSETS}logo.png" alt="DARK LIMITS" style="width:min(500px, 74vw); height:auto; display:block;" />
        </div>

        <div class="menuTextBig">Completa los puzzles,<br>
          avanza a trav√©s de los 5 niveles<br>
          y descubre qu√© pas√≥<br>
          el fat√≠dico 9 de noviembre de 2020...</div>

        <div style="height:12px"></div>

        <div class="btns" style="justify-content:center;">
          <button class="primary" id="menuPlay">JUGAR</button>
          <button id="menuContinue" style="display:none;">CONTINUAR</button>
          <button id="menuRestart" style="display:none;">REINICIAR</button>
          <button id="menuFinalVideo" style="display:none; border-color: rgba(255,60,60,0.9); background: rgba(255,60,60,0.22);">VER VIDEO FINAL</button>
          <button id="menuHow">C√ìMO JUGAR</button>
          <a class="btnlink" href="https://www.disturbingstories.com/dark-limits-prelude.html" target="_blank" rel="noopener">Descubre DARK LIMITS</a>
        </div>

        <div class="menuFooter" style="margin-top:14px; padding-top:12px;">
          ¬© Disturbing Stories 2026 / Vianda Visual /
          <a class="pillLink" href="https://www.disturbingstories.com" target="_blank" rel="noopener">www.disturbingstories.com</a>
        </div>
      `
    });

    // Centrar la caja exactamente (horizontal y vertical)
    if (menuWin){
      const rect = menuWin.getBoundingClientRect();
      const nx = Math.round((window.innerWidth - rect.width)/2);
      const ny = Math.round((window.innerHeight - rect.height)/2);
      menuWin.style.left = Math.max(12, nx) + "px";
      menuWin.style.top = Math.max(12, ny - 40) + "px";
    }

    document.getElementById("menuPlay").addEventListener("click", () => {
      showScreen("game");
      buildGameWindows();
      loadLevel(0);
    });
    // Estado del men√∫ seg√∫n progreso
    const btnPlay = document.getElementById("menuPlay");
    const btnCont = document.getElementById("menuContinue");
    const btnRestart = document.getElementById("menuRestart");
    const btnFinal = document.getElementById("menuFinalVideo");

    const showCompletedMenu = () => {
      if (btnPlay) btnPlay.style.display = "none";
      if (btnCont) btnCont.style.display = "none";
      if (btnRestart) btnRestart.style.display = "";
      if (btnFinal) btnFinal.style.display = "";
    };

    const showNormalMenu = () => {
      if (btnPlay) btnPlay.style.display = "";
      if (btnRestart) btnRestart.style.display = "none";
      if (btnFinal) btnFinal.style.display = "none";
      if (btnCont){
        if (typeof levelIndex === "number" && levelIndex > 0){
          btnCont.style.display = "";
        } else {
          btnCont.style.display = "none";
        }
      }
    };

    if (gameCompletedAll){
      showCompletedMenu();
    } else {
      showNormalMenu();
    }

    if (btnCont){
      btnCont.onclick = () => {
        showScreen("game");
        buildGameWindows();
        loadLevel(levelIndex || 0);
      };
    }

    if (btnRestart){
      btnRestart.onclick = () => {
        gameCompletedAll = false;
        levelIndex = 0;
        buildMenu();
      };
    }

    if (btnFinal){
      btnFinal.onclick = async () => {
        await playFinalVideoFromMenu();
      };
    }


    document.getElementById("menuHow").addEventListener("click", () => {
      showScreen("how");
      buildHow();
    });
  }


  function buildHow(){
    removeAllWindows();
    ensureMenuAmbience();

    const howWin = makeWindow({
      id: "how",
      title: "C√≥mo jugar",
      x: Math.round((window.innerWidth - 520)/2),
      y: Math.round((window.innerHeight - 340)/2),
      w: Math.min(520, window.innerWidth - 36),
      closable: false,
      contentHTML: `
        <div style="color:#fff; font-size:18px; line-height:1.5; font-weight:400;">
          <p style="margin-top:0; color:#fff;">
            Arrastra piezas (mouse o t√°ctil). Si una pieza queda cerca de su posici√≥n correcta, encaja autom√°ticamente.
          </p>
          <ul style="margin:0; padding-left:20px; color:#fff; line-height:1.5; font-size:18px; font-weight:400;">
            <li>Las piezas pueden moverse por toda la pantalla.</li>
            <li>Completa el nivel para avanzar.</li>
            <li>Recuerda que puedes mover las ventanas flotantes.</li>
          </ul>
        </div>

        <div class="btns" style="margin-top:16px; justify-content:center;">
          <button class="primary" id="howBack">VOLVER</button>
        </div>
      `
    });

    if (howWin){
      const rect = howWin.getBoundingClientRect();
      const nx = Math.round((window.innerWidth - rect.width)/2);
      const ny = Math.round((window.innerHeight - rect.height)/2);
      howWin.style.left = Math.max(12, nx) + "px";
      howWin.style.top  = Math.max(12, ny) + "px";
    }

    document.getElementById("howBack").addEventListener("click", () => {
      showScreen("menu");
      buildMenu();
    });

    stage.style.display = "none";
  }

  // ========= GAME =========
  const SNAP_TOL = 28;
  const PAD = 34;
  const TAB_SIZE = 0.33;
  const TAB_NECK = 0.12;

  let levelIndex = 0;
  let img = new Image();
  img.decoding = "async";

  let COLS = 5, ROWS = 5, TOTAL = 25;
  let pieceW = 0, pieceH = 0;

  let pieces = [];
  let zTop = 50;
  let lockedCount = 0;

  let timerId = null;
  let startTs = null;

  let boardX = 0, boardY = 0, boardSizePx = 0;

  function fmtTime(ms){
    const s = Math.floor(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }
  function startTimer(updateCb){
    if (timerId) return;
    startTs = performance.now();
    timerId = setInterval(() => updateCb(fmtTime(performance.now() - startTs)), 250);
  }
  function stopTimer(){
    if (timerId){ clearInterval(timerId); timerId = null; }
  }
  function resetTimerUI(updateCb){
    stopTimer();
    updateCb("00:00");
  }

  function piecesToGrid(n){
    const root = Math.sqrt(n);
    const k = Math.round(root);
    return {cols:k, rows:k};
  }
  function rand(min,max){ return Math.random()*(max-min)+min; }

  function layoutBoard(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const size = Math.min(760, Math.min(vw, vh) - 60);
    boardSizePx = Math.max(320, size);

    board.style.width = boardSizePx + "px";
    const left = Math.round((vw - boardSizePx) / 2);
    const top  = Math.round((vh - boardSizePx) / 2);
    boardX = left;
    boardY = top;
    board.style.left = boardX + "px";
    board.style.top  = boardY + "px";

    pieceW = boardSizePx / COLS;
    pieceH = boardSizePx / ROWS;
  }

  function generateEdges(){
    const edges = Array.from({length: ROWS}, () =>
      Array.from({length: COLS}, () => ({t:0,r:0,b:0,l:0}))
    );
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const e = edges[r][c];
        e.t = (r === 0) ? 0 : -edges[r-1][c].b;
        e.l = (c === 0) ? 0 : -edges[r][c-1].r;
        e.b = (r === ROWS-1) ? 0 : (Math.random() > 0.5 ? 1 : -1);
        e.r = (c === COLS-1) ? 0 : (Math.random() > 0.5 ? 1 : -1);
      }
    }
    return edges;
  }

  function jigsawEdge(ctx, len, sign, tab, neck){
    const mid = len * 0.5;
    const tabW = tab;
    const neckW = neck;
    const x1 = mid - tabW;
    const x2 = mid - neckW;
    const x3 = mid + neckW;
    const x4 = mid + tabW;

    ctx.lineTo(x1, 0);
    if (sign === 0){ ctx.lineTo(len, 0); return; }

    const s = sign;
    ctx.lineTo(x2, 0);
    ctx.bezierCurveTo(x2, 0, x2, s * tab * 0.35, mid, s * tab * 0.35);

    ctx.bezierCurveTo(
      mid + (tabW - neckW) * 0.2, s * tab * 0.35,
      mid + (tabW - neckW) * 0.75, s * tab,
      mid, s * tab
    );
    ctx.bezierCurveTo(
      mid - (tabW - neckW) * 0.75, s * tab,
      mid - (tabW - neckW) * 0.2, s * tab * 0.35,
      mid, s * tab * 0.35
    );

    ctx.bezierCurveTo(mid, s * tab * 0.35, x3, s * tab * 0.35, x3, 0);
    ctx.lineTo(x4, 0);
    ctx.lineTo(len, 0);
  }

  function piecePath(ctx, w, h, e){
    const tab = Math.min(w, h) * TAB_SIZE;
    const neck = Math.min(w, h) * TAB_NECK;

    ctx.beginPath();
    ctx.moveTo(PAD, PAD);

    ctx.save(); ctx.translate(PAD, PAD); jigsawEdge(ctx, w, e.t, tab, neck); ctx.restore();
    ctx.save(); ctx.translate(PAD + w, PAD); ctx.rotate(Math.PI/2); jigsawEdge(ctx, h, e.r, tab, neck); ctx.restore();
    ctx.save(); ctx.translate(PAD + w, PAD + h); ctx.rotate(Math.PI); jigsawEdge(ctx, w, e.b, tab, neck); ctx.restore();
    ctx.save(); ctx.translate(PAD, PAD + h); ctx.rotate(-Math.PI/2); jigsawEdge(ctx, h, e.l, tab, neck); ctx.restore();

    ctx.closePath();
  }

  function drawPieceCanvas(r, c, edgesRC){
    const w = pieceW, h = pieceH;
    const cw = Math.ceil(w + PAD*2) + 2;
    const ch = Math.ceil(h + PAD*2) + 2;

    const canvas = document.createElement("canvas");
    canvas.width = cw; canvas.height = ch;

    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;

    ctx.save();
    piecePath(ctx, w, h, edgesRC);
    ctx.clip();

    const imgAR = img.width / img.height;
    const boxAR = 1;
    let drawW, drawH, offX, offY;
    if (imgAR > boxAR){
      drawH = boardSizePx;
      drawW = boardSizePx * imgAR;
      offX = -(drawW - boardSizePx)/2;
      offY = 0;
    } else {
      drawW = boardSizePx;
      drawH = boardSizePx / imgAR;
      offX = 0;
      offY = -(drawH - boardSizePx)/2;
    }

    const sx = c * w;
    const sy = r * h;
    ctx.drawImage(img, offX - sx + PAD + 1, offY - sy + PAD + 1, drawW, drawH);
    ctx.restore();

    return canvas;
  }

  function clearPieces(){ stage.querySelectorAll(".piece").forEach(el => el.remove()); }
  function clearGameState(){
    clearPieces();
    pieces = [];
    lockedCount = 0;
  }

  function trySnap(piece, updateLockedCb){
    if (piece.locked) return;
    const dx = piece.x - piece.correctX;
    const dy = piece.y - piece.correctY;

    if (Math.hypot(dx,dy) <= SNAP_TOL){
      piece.locked = true;
      piece.x = piece.correctX;
      piece.y = piece.correctY;
      piece.el.style.left = `${piece.x}px`;
      piece.el.style.top  = `${piece.y}px`;
      piece.el.classList.add("locked");
      piece.el.style.zIndex = "10";

      lockedCount++;
      updateLockedCb(String(lockedCount));

      if (lockedCount === TOTAL){
        stopTimer();
        onLevelCompleted();
      } else if (lockedCount % Math.max(3, Math.floor(TOTAL/6)) === 0){
        showToastIn("controls", `¬°Bien! ${lockedCount}/${TOTAL}`);
      }
    }
  }

  function attachDrag(piece, updateTimeCb, updateLockedCb){
    const el = piece.el;
    let dragging = false, startPX = 0, startPY = 0, startX = 0, startY = 0;

    el.addEventListener("pointerdown", (ev) => {
      if (piece.locked) return;
      ev.preventDefault();
      startTimer(updateTimeCb);
      dragging = true;
      el.setPointerCapture(ev.pointerId);
      el.style.zIndex = String(++zTop);

      startPX = ev.clientX; startPY = ev.clientY;
      startX = piece.x; startY = piece.y;
    });

    el.addEventListener("pointermove", (ev) => {
      if (!dragging || piece.locked) return;
      const dx = ev.clientX - startPX;
      const dy = ev.clientY - startPY;

      const vw = window.innerWidth;
      const vh = window.innerHeight;

      piece.x = clamp(startX + dx, -piece.w + 30, vw - 30);
      piece.y = clamp(startY + dy, -piece.h + 30, vh - 30);

      el.style.left = `${piece.x}px`;
      el.style.top  = `${piece.y}px`;
    });

    const up = () => {
      if (!dragging) return;
      dragging = false;
      trySnap(piece, updateLockedCb);
    };
    el.addEventListener("pointerup", up);
    el.addEventListener("pointercancel", up);
  }

  function shufflePieces(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    for (const p of pieces){
      if (p.locked) continue;
      p.x = rand(20, vw - p.w - 20);
      p.y = rand(20, vh - p.h - 20);
      p.el.style.left = `${p.x}px`;
      p.el.style.top  = `${p.y}px`;
      p.el.style.zIndex = String(++zTop);
    }
    showToastIn("controls", "Piezas mezcladas");
  }

  // ========= Game windows =========
  let controlRefs = null;

  function buildGameWindows(){
    removeAllWindows();

    const cw = Math.min(280, window.innerWidth - 24); // ~half of old 360
    const controlWin = makeWindow({
      id: "controls",
      title: "Controles",
      x: 14,
      y: 14,
      w: cw,
      closable: false,
      contentHTML: `
        <div class="miniTitle" id="uiTitle">Puzzle 1</div>
        <div class="miniDesc" id="uiDesc">Completa el puzzle para pasar al siguiente nivel.</div>

        <div class="btns">
          <button class="primary" id="btnShuffle">Mezclar</button>
          <button id="btnRestartLevel">Reiniciar</button>
          <button id="btnBackMenu">Men√∫</button>
        </div>

        <div class="btns">
          <button id="btnShowTablero">Informaci√≥n del tablero</button>
        </div>

        <div class="audioRow">
          <button id="btnAudioToggle">üîä</button>
          <label for="audioVol">Vol</label>
          <input id="audioVol" type="range" min="0" max="1" step="0.01" value="0.65" />
          <span class="small" id="audioStatus">Listo</span>
        </div>

        <div class="statsBig" aria-live="polite">
          <div class="row"><span>Piezas</span> <b id="statPieces">0</b></div>
          <div class="row"><span>Encajadas</span> <b id="statLocked">0</b></div>
          <div class="row"><span>Tiempo</span> <b id="statTime">00:00</b></div>
        </div>

        <div id="toast" class="toast" style="margin-top:10px;"></div>
      `
    });
    controlWin.classList.add("controlsCompact");

    const tableroWin = makeWindow({
      id: "tablero",
      title: "Tablero",
      x: Math.max(320, window.innerWidth - 14 - 320),
      y: 14,
      w: Math.min(320, window.innerWidth - 24),
      closable: true,
      contentHTML: `
        <p class="small">El tablero es el cuadrado en el centro.</p>
        <p class="small">Las piezas encajan por proximidad.</p>
        <p class="small">Consejo: arrastra piezas fuera del tablero para despejar espacio.</p>
      `
    });
    tableroWin.style.display = "none";

    // Wire controls
    const uiTitle = document.getElementById("uiTitle");
    const uiDesc  = document.getElementById("uiDesc");
    const statPieces = document.getElementById("statPieces");
    const statLocked = document.getElementById("statLocked");
    const statTime   = document.getElementById("statTime");

    const btnShuffle = document.getElementById("btnShuffle");
    const btnRestartLevel = document.getElementById("btnRestartLevel");
    const btnBackMenu = document.getElementById("btnBackMenu");
    const btnShowTablero = document.getElementById("btnShowTablero");

    const btnAudioToggle = document.getElementById("btnAudioToggle");
    const audioVol = document.getElementById("audioVol");
    const audioStatus = document.getElementById("audioStatus");

    bgAudio.volume = Number(audioVol.value);
    lastBgVolume = bgAudio.volume;

    audioVol.addEventListener("input", () => {
      lastBgVolume = Number(audioVol.value);
      bgAudio.volume = lastBgVolume;
    });
    btnAudioToggle.addEventListener("click", () => toggleAudio(audioStatus, btnAudioToggle));

    btnShuffle.addEventListener("click", shufflePieces);
    btnRestartLevel.addEventListener("click", () => { loadLevel(levelIndex); });
    btnBackMenu.addEventListener("click", () => {
      stopTimer();
      showScreen("menu");
      buildMenu();
    });

    btnShowTablero.addEventListener("click", () => { tableroWin.style.display = "block"; tableroWin.style.zIndex = String(++winZ); });

    controlRefs = {
      uiTitle, uiDesc, statPieces, statLocked, statTime,
      audioStatus,
      btnAudioToggle,
      audioVol
    };
  }


  function showBonusHint(){
    const existing = getWindow("bonusHint");
    if (existing){
      existing.style.display = "block";
      existing.style.zIndex = String(++winZ);
      return;
    }
    const w = Math.min(420, window.innerWidth - 24);
    const x = Math.round((window.innerWidth - w)/2);
    const y = Math.round(boardY + boardSizePx*0.12);

    makeWindow({
      id: "bonusHint",
      title: "NIVEL BONUS",
      x, y, w,
      closable: true,
      draggable: false,
      contentHTML: `
        <p style="margin:0; color:#fff; font-size:16px; line-height:1.35; text-align:center; font-weight:700;">
          ¬°Termina este NIVEL BONUS y gana una recompensa!
        </p>
      `
    });
  }

  // ========= Completion =========
  function playSuccessSfx(){
    try{
      sfxSuccess.currentTime = 0;
      sfxSuccess.volume = 1;
      tryPlay(sfxSuccess);
    }catch(e){}
  }

  function showCompletionOverlay(){
    const isFinal = (levelIndex === LEVELS.length - 1);
    const imgSrc = isFinal ? COMPLETE_FINAL_IMG : COMPLETE_IMG;

    let w = getWindow("completed");
    if (!w){
      w = makeWindow({
        id:"completed",
        title:"",
        x: Math.round((window.innerWidth - 560)/2),
        y: Math.round((window.innerHeight - 320)/2),
        w: Math.min(560, window.innerWidth - 24),
        closable:false,
        contentHTML: `
          <div class="completeWrap">
            <img class="completeImg" src="${imgSrc}" alt="Completado" />
            <div class="completeLine">Has terminado este nivel.</div>
            <div class="btns" style="margin-top:18px; justify-content:center;">
              <button class="primary" id="btnNextFlow">${isFinal ? "Volver al men√∫" : "Siguiente"}</button>
            </div>
          </div>
        `
      });
    } else {
      w.style.display="block";
      w.style.zIndex = String(++winZ);
      const imgEl = w.querySelector(".completeImg");
      if (imgEl) imgEl.src = imgSrc;
      const btn = w.querySelector("#btnNextFlow");
      if (btn) btn.textContent = isFinal ? "Volver al men√∫" : "Siguiente";
    }

    const btn = w.querySelector("#btnNextFlow");
    if (btn){
      btn.onclick = async () => {
        w.style.display="none";
        await playPostLevelThenContinue();
      };
    }
  }

  async function playPostLevelThenContinue(){
    // Mandatory post video (fullscreen). Mute bg music during.
    muteBgMusic();

    postOverlay.classList.add("on");
    postVideo.controls = false;
    postVideo.muted = false;
    postVideo.playsInline = true;
    postVideo.src = postVideoForLevel(levelIndex);
    postVideo.load();

    // Prevent interactions
    stage.classList.add("disabled");
    windows.style.pointerEvents = "none";
    // Autoplay fallback (sin reutilizar la intro)
    if (postGate) postGate.classList.remove("on");
    await tryPlay(postVideo);
    if (postVideo.paused){
      if (postGate) postGate.classList.add("on");
      if (postBtn){
        postBtn.onclick = async () => {
          if (postGate) postGate.classList.remove("on");
          await tryPlay(postVideo);
        };
      }
    } else {
      if (postGate) postGate.classList.remove("on");
    }

    await new Promise((resolve) => {
      postVideo.onended = () => resolve();
    });

    // Continue flow
    if (levelIndex < LEVELS.length - 1){
      // Cargar siguiente nivel SIN quitar el overlay para evitar ver el tablero anterior
      await loadLevel(levelIndex + 1);
      if (levelIndex === LEVELS.length - 1){
        showBonusHint();
      }
      if (postGate) postGate.classList.remove("on");
      postOverlay.classList.remove("on");
      postVideo.pause();
      postVideo.src = "";

      // Restore interactions
      windows.style.pointerEvents = "";
      stage.classList.remove("disabled");

      unmuteBgMusic();
      return;
    } else {
      // √öltimo nivel: volver al men√∫ directamente
      gameCompletedAll = true;
      if (postGate) postGate.classList.remove("on");
      postOverlay.classList.remove("on");
      postVideo.pause();
      postVideo.src = "";

      windows.style.pointerEvents = "";
      stage.classList.remove("disabled");

      unmuteBgMusic();
      showScreen("menu");
      buildMenu();
      return;
    }
  }

  async function playFinalVideoFromMenu(){
    muteBgMusic();

    postOverlay.classList.add("on");
    postVideo.controls = false;
    postVideo.muted = false;
    postVideo.playsInline = true;
    postVideo.src = postVideoForLevel(LEVELS.length - 1);
    postVideo.load();

    windows.style.pointerEvents = "none";
    stage.classList.add("disabled");
    // Autoplay fallback (sin reutilizar la intro)
    if (postGate) postGate.classList.remove("on");
    await tryPlay(postVideo);
    if (postVideo.paused){
      if (postGate) postGate.classList.add("on");
      if (postBtn){
        postBtn.onclick = async () => {
          if (postGate) postGate.classList.remove("on");
          await tryPlay(postVideo);
        };
      }
    } else {
      if (postGate) postGate.classList.remove("on");
    }

    await new Promise((resolve) => { postVideo.onended = () => resolve(); });

    if (postGate) postGate.classList.remove("on");

    postOverlay.classList.remove("on");
    postVideo.pause();
    postVideo.src = "";

    windows.style.pointerEvents = "";
    stage.classList.remove("disabled");

    gameCompletedAll = true;
    unmuteBgMusic();
    showScreen("menu");
    buildMenu();
  }


  function onLevelCompleted(){
    playSuccessSfx();

    stage.classList.add("celebrate","disabled");
    const fx = document.getElementById("fxFlash");
    if (fx){
      fx.style.animation = "none";
      fx.offsetHeight;
      fx.style.animation = "flashPop 2s ease-in-out both";
    }
    setTimeout(() => {
      stage.classList.remove("celebrate","disabled");
      showCompletionOverlay();
    }, 2000);
  }

  // ========= Level flow =========
  function createPieces(updateTimeCb, updateLockedCb){
    pieces = [];
    lockedCount = 0;

    const edges = generateEdges();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const el = document.createElement("div");
        el.className = "piece";
        el.style.zIndex = String(++zTop);

        const canvas = drawPieceCanvas(r, c, edges[r][c]);
        el.appendChild(canvas);

        const correctX = boardX + c * pieceW - PAD;
        const correctY = boardY + r * pieceH - PAD;

        const pw = canvas.width;
        const ph = canvas.height;

        let startX, startY;
        const region = Math.floor(Math.random()*4);
        if (region === 0){
          startX = rand(20, Math.max(40, boardX - pw - 20));
          startY = rand(20, vh - ph - 20);
        } else if (region === 1){
          startX = rand(Math.min(vw - pw - 20, boardX + boardSizePx + 20), vw - pw - 20);
          startY = rand(20, vh - ph - 20);
        } else if (region === 2){
          startX = rand(20, vw - pw - 20);
          startY = rand(20, Math.max(40, boardY - ph - 20));
        } else {
          startX = rand(20, vw - pw - 20);
          startY = rand(Math.min(vh - ph - 20, boardY + boardSizePx + 20), vh - ph - 20);
        }
        if (!isFinite(startX) || !isFinite(startY)){
          startX = rand(20, vw - pw - 20);
          startY = rand(20, vh - ph - 20);
        }

        el.style.left = `${startX}px`;
        el.style.top  = `${startY}px`;

        const piece = { r, c, el, locked:false, correctX, correctY, x:startX, y:startY, w:pw, h:ph };
        attachDrag(piece, updateTimeCb, updateLockedCb);
        pieces.push(piece);
        stage.appendChild(el);
      }
    }
  }

  function loadLevel(index){
    return new Promise((resolve) => {
      levelIndex = index;
      const L = LEVELS[levelIndex];

      const uiTitle = controlRefs.uiTitle;
      const uiDesc  = controlRefs.uiDesc;
      const statPieces = controlRefs.statPieces;
      const statLocked = controlRefs.statLocked;
      const statTime = controlRefs.statTime;

      showToastIn("controls", "", "");
      statLocked.textContent = "0";

      const grid = piecesToGrid(L.pieces);
      COLS = grid.cols;
      ROWS = grid.rows;
      TOTAL = L.pieces;

      uiTitle.textContent = L.name;
      uiDesc.textContent = `${TOTAL} piezas (${COLS}√ó${ROWS})`;
      statPieces.textContent = String(TOTAL);
      resetTimerUI((t) => { statTime.textContent = t; });

      // Hide stage during asset swap to avoid flicker
      stage.style.visibility = "hidden";

      // bg + audio per level
      setBackground(L.bg);
      bgAudio.volume = Number(controlRefs.audioVol.value);
      lastBgVolume = bgAudio.volume;
      setAudio(L.audio);
      if (controlRefs.audioStatus) controlRefs.audioStatus.textContent = audioEnabled ? "Reproduciendo" : "Silenciado";

      img = new Image();
      img.decoding = "async";
      img.src = L.img;

      img.onload = () => {
        clearGameState();
        layoutBoard();

        const updateTimeCb = (t) => { statTime.textContent = t; };
        const updateLockedCb = (v) => { statLocked.textContent = v; };

        createPieces(updateTimeCb, updateLockedCb);
        stage.style.visibility = "visible";
        showToastIn("controls", "Listo");
        resolve();
      };

      img.onerror = () => {
        clearGameState();
        stage.style.visibility = "visible";
        showToastIn("controls", "No se pudo cargar la imagen (revisa assets/)", "warn");
        resolve();
      };
    });
  }

  // Resize: keep board + locked pieces aligned
  let resizeT = null;
  window.addEventListener("resize", () => {
    if (stage.style.display !== "block") return;
    clearTimeout(resizeT);
    resizeT = setTimeout(() => {
      layoutBoard();
      for (const p of pieces){
        p.correctX = boardX + p.c * pieceW - PAD;
        p.correctY = boardY + p.r * pieceH - PAD;
        if (p.locked){
          p.x = p.correctX;
          p.y = p.correctY;
          p.el.style.left = `${p.x}px`;
          p.el.style.top  = `${p.y}px`;
        }
      }
    }, 120);
  });

  // ========= INIT =========
  (async () => {
    // Start mandatory intro, then menu
    await runIntroThenMenu();
  })();
})();
</script>
</body>
</html>
